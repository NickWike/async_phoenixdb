# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: common.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List
import betterproto


class StatementType(betterproto.Enum):
    """Has to be consistent with Meta.StatementType"""

    SELECT = 0
    INSERT = 1
    UPDATE = 2
    DELETE = 3
    UPSERT = 4
    MERGE = 5
    OTHER_DML = 6
    CREATE = 7
    DROP = 8
    ALTER = 9
    OTHER_DDL = 10
    CALL = 11


class Rep(betterproto.Enum):
    PRIMITIVE_BOOLEAN = 0
    PRIMITIVE_BYTE = 1
    PRIMITIVE_CHAR = 2
    PRIMITIVE_SHORT = 3
    PRIMITIVE_INT = 4
    PRIMITIVE_LONG = 5
    PRIMITIVE_FLOAT = 6
    PRIMITIVE_DOUBLE = 7
    BOOLEAN = 8
    BYTE = 9
    CHARACTER = 10
    SHORT = 11
    INTEGER = 12
    LONG = 13
    FLOAT = 14
    DOUBLE = 15
    BIG_INTEGER = 25
    BIG_DECIMAL = 26
    JAVA_SQL_TIME = 16
    JAVA_SQL_TIMESTAMP = 17
    JAVA_SQL_DATE = 18
    JAVA_UTIL_DATE = 19
    BYTE_STRING = 20
    STRING = 21
    NUMBER = 22
    OBJECT = 23
    NULL = 24
    ARRAY = 27
    STRUCT = 28
    MULTISET = 29


class Severity(betterproto.Enum):
    """
    The severity of some unexpected outcome to an operation. Protobuf enum
    values must be unique across all other enums
    """

    UNKNOWN_SEVERITY = 0
    FATAL_SEVERITY = 1
    ERROR_SEVERITY = 2
    WARNING_SEVERITY = 3


class MetaDataOperation(betterproto.Enum):
    """Enumeration corresponding to DatabaseMetaData operations"""

    GET_ATTRIBUTES = 0
    GET_BEST_ROW_IDENTIFIER = 1
    GET_CATALOGS = 2
    GET_CLIENT_INFO_PROPERTIES = 3
    GET_COLUMN_PRIVILEGES = 4
    GET_COLUMNS = 5
    GET_CROSS_REFERENCE = 6
    GET_EXPORTED_KEYS = 7
    GET_FUNCTION_COLUMNS = 8
    GET_FUNCTIONS = 9
    GET_IMPORTED_KEYS = 10
    GET_INDEX_INFO = 11
    GET_PRIMARY_KEYS = 12
    GET_PROCEDURE_COLUMNS = 13
    GET_PROCEDURES = 14
    GET_PSEUDO_COLUMNS = 15
    GET_SCHEMAS = 16
    GET_SCHEMAS_WITH_ARGS = 17
    GET_SUPER_TABLES = 18
    GET_SUPER_TYPES = 19
    GET_TABLE_PRIVILEGES = 20
    GET_TABLES = 21
    GET_TABLE_TYPES = 22
    GET_TYPE_INFO = 23
    GET_UDTS = 24
    GET_VERSION_COLUMNS = 25


class StateType(betterproto.Enum):
    SQL = 0
    METADATA = 1


class CursorFactoryStyle(betterproto.Enum):
    OBJECT = 0
    RECORD = 1
    RECORD_PROJECTION = 2
    ARRAY = 3
    LIST = 4
    MAP = 5


class MetaDataOperationArgumentArgumentType(betterproto.Enum):
    STRING = 0
    BOOL = 1
    INT = 2
    REPEATED_STRING = 3
    REPEATED_INT = 4
    NULL = 5


@dataclass
class ConnectionProperties(betterproto.Message):
    """Details about a connection"""

    is_dirty: bool = betterproto.bool_field(1)
    auto_commit: bool = betterproto.bool_field(2)
    has_auto_commit: bool = betterproto.bool_field(7)
    read_only: bool = betterproto.bool_field(3)
    has_read_only: bool = betterproto.bool_field(8)
    transaction_isolation: int = betterproto.uint32_field(4)
    catalog: str = betterproto.string_field(5)
    schema: str = betterproto.string_field(6)


@dataclass
class StatementHandle(betterproto.Message):
    """Statement handle"""

    connection_id: str = betterproto.string_field(1)
    id: int = betterproto.uint32_field(2)
    signature: "Signature" = betterproto.message_field(3)


@dataclass
class Signature(betterproto.Message):
    """Results of preparing a statement"""

    columns: List["ColumnMetaData"] = betterproto.message_field(1)
    sql: str = betterproto.string_field(2)
    parameters: List["AvaticaParameter"] = betterproto.message_field(3)
    cursor_factory: "CursorFactory" = betterproto.message_field(4)
    statement_type: "StatementType" = betterproto.enum_field(5)


@dataclass
class ColumnMetaData(betterproto.Message):
    ordinal: int = betterproto.uint32_field(1)
    auto_increment: bool = betterproto.bool_field(2)
    case_sensitive: bool = betterproto.bool_field(3)
    searchable: bool = betterproto.bool_field(4)
    currency: bool = betterproto.bool_field(5)
    nullable: int = betterproto.uint32_field(6)
    signed: bool = betterproto.bool_field(7)
    display_size: int = betterproto.uint32_field(8)
    label: str = betterproto.string_field(9)
    column_name: str = betterproto.string_field(10)
    schema_name: str = betterproto.string_field(11)
    precision: int = betterproto.uint32_field(12)
    scale: int = betterproto.uint32_field(13)
    table_name: str = betterproto.string_field(14)
    catalog_name: str = betterproto.string_field(15)
    read_only: bool = betterproto.bool_field(16)
    writable: bool = betterproto.bool_field(17)
    definitely_writable: bool = betterproto.bool_field(18)
    column_class_name: str = betterproto.string_field(19)
    type: "AvaticaType" = betterproto.message_field(20)


@dataclass(eq=False, repr=False)
class AvaticaType(betterproto.Message):
    """Base class for a column type"""

    id: int = betterproto.uint32_field(1)
    name: str = betterproto.string_field(2)
    rep: "Rep" = betterproto.enum_field(3)
    columns: List["ColumnMetaData"] = betterproto.message_field(4)
    component: "AvaticaType" = betterproto.message_field(5)


@dataclass
class AvaticaParameter(betterproto.Message):
    """Metadata for a parameter"""

    signed: bool = betterproto.bool_field(1)
    precision: int = betterproto.uint32_field(2)
    scale: int = betterproto.uint32_field(3)
    parameter_type: int = betterproto.uint32_field(4)
    type_name: str = betterproto.string_field(5)
    class_name: str = betterproto.string_field(6)
    name: str = betterproto.string_field(7)


@dataclass
class CursorFactory(betterproto.Message):
    """Information necessary to convert an Iterable into a Calcite Cursor"""

    style: "CursorFactoryStyle" = betterproto.enum_field(1)
    class_name: str = betterproto.string_field(2)
    field_names: List[str] = betterproto.string_field(3)


@dataclass
class Frame(betterproto.Message):
    """A collection of rows"""

    offset: int = betterproto.uint64_field(1)
    done: bool = betterproto.bool_field(2)
    rows: List["Row"] = betterproto.message_field(3)


@dataclass
class Row(betterproto.Message):
    """A row is a collection of values"""

    value: List["ColumnValue"] = betterproto.message_field(1)


@dataclass
class DatabaseProperty(betterproto.Message):
    """
    Database property, list of functions the database provides for a certain
    operation
    """

    name: str = betterproto.string_field(1)
    functions: List[str] = betterproto.string_field(2)


@dataclass
class WireMessage(betterproto.Message):
    """
    Message which encapsulates another message to support a single RPC endpoint
    """

    name: str = betterproto.string_field(1)
    wrapped_message: bytes = betterproto.bytes_field(2)


@dataclass
class ColumnValue(betterproto.Message):
    """A value might be a TypedValue or an Array of TypedValue's"""

    value: List["TypedValue"] = betterproto.message_field(1)
    array_value: List["TypedValue"] = betterproto.message_field(2)
    has_array_value: bool = betterproto.bool_field(3)
    scalar_value: "TypedValue" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class TypedValue(betterproto.Message):
    """
    Generic wrapper to support any SQL type. Struct-like to work around no
    polymorphism construct.
    """

    type: "Rep" = betterproto.enum_field(1)
    bool_value: bool = betterproto.bool_field(2)
    string_value: str = betterproto.string_field(3)
    number_value: int = betterproto.sint64_field(4)
    # includes numeric types and date/time types.
    bytes_value: bytes = betterproto.bytes_field(5)
    double_value: float = betterproto.double_field(6)
    null: bool = betterproto.bool_field(7)
    array_value: List["TypedValue"] = betterproto.message_field(8)
    component_type: "Rep" = betterproto.enum_field(9)
    implicitly_null: bool = betterproto.bool_field(10)


@dataclass
class MetaDataOperationArgument(betterproto.Message):
    """Represents the breadth of arguments to DatabaseMetaData functions"""

    string_value: str = betterproto.string_field(1)
    bool_value: bool = betterproto.bool_field(2)
    int_value: int = betterproto.sint32_field(3)
    string_array_values: List[str] = betterproto.string_field(4)
    int_array_values: List[int] = betterproto.sint32_field(5)
    type: "MetaDataOperationArgumentArgumentType" = betterproto.enum_field(6)


@dataclass
class QueryState(betterproto.Message):
    type: "StateType" = betterproto.enum_field(1)
    sql: str = betterproto.string_field(2)
    op: "MetaDataOperation" = betterproto.enum_field(3)
    args: List["MetaDataOperationArgument"] = betterproto.message_field(4)
    has_args: bool = betterproto.bool_field(5)
    has_sql: bool = betterproto.bool_field(6)
    has_op: bool = betterproto.bool_field(7)
